<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>Document</title>
</head>
<body>
	es6
	
	   let  是声明变量的 是一个块级作用域
	   
	   1.产生块级作用域
	   2.没有预解析的过程
	   
	   
	   let 声明的变量 只在他声明的所在代码块内有效
	   
	   例   
	   
	   {
	   	
	   	let a=20;
	   	
	   	let b=1;
	   	
	   }
	   
	   
	   let  适合在 for循环中使用
	   
	   
	   例  
	   
	   for(let i=0;i<10;i++){
	   	  //...
	   }
	   
	   for (let i = 0; i < 3; i++) {
			  let i = 'abc';
			  console.log(i);
			}
			// abc
			// abc
			// abc
	   
	   这里输出了三次abc  说明函数内部变量 i  和  循环变量i  不是同一个作用域
	   
	   
	   let 声明的变量必须在声明后才能使用 否者报错
	   
	   只要块级作用域内 存在let命令 那么他声明的变量 就bind 在这个区域了 不在受到外部的影响
	   
	   例
	   
	   var tmp = 123;

			if (true) {
			  tmp = 'abc'; // ReferenceError  报错
			  let tmp;
			}
	   
	   
	   在代码快内未声明不能使用 叫做暂时性死区
	   
	   在相同的作用域内  不能重复声明同一个变量
	   
	   不能声明参数
	   
	   
		  // 报错
			function () {
			  let a = 10;
			  var a = 1;
			}
			
			// 报错
			function () {
			  let a = 10;
			  let a = 1;
			}
	   
	   
	   function func(arg) {
		  let arg; // 报错
		}
		
		function func(arg) {
		  {
		    let arg; // 不报错
		  }
		}
	   
	   
	   function f1() {
		  let n = 5;
		  if (true) {
		    let n = 10;
		  }
		  console.log(n); // 5   代码块不同 互不干扰
		}
	   
	   
	   外层的代码块是无法使用内层的变量的	   
	   
	   不同的代码区域 可以定义相同的变量
	   
	   块级作用域没有返回值
	   
	   在块级作用域之前 加一个do  那么他就会有 返回值
	   
	   
	   例
	   
	     {    }   两个大括号 就是跨级作用域
	     
	     
	     
	   let x = do {
		  let t = f();
		  t * t + 1;
		};
	   
	     
	   
	   const 是声明常量的
	   
	   
	        常量声明 就不能改变  改变过常量的值会报错
	         
	        这就意味着  一旦声明 常量就得马上赋值   只申明不赋值 就会报错
	        
	        
	        const 和  let  只在区域块有用 
	        
	        
	        常量必须赋值
	        
	        基本数据类型数据不可改变
	        
	        如果是一个对象里面的值可以改变
	        
	        
	        例
	        
	           const a={b:30}
	           
	           
	           a.b=49;
	           
	           console.log(a.b)//49
	           
	           
	    结构赋值
	    
	      let a=1;
	      let b=2;
	      let c=3;
	      
	      类同
	      
	      let [a,b,c]=[1,2,3]
	      
	      
	      数组的结构赋值
	      
	      结构赋值 是一种匹配模式 如果模式相同 就会被赋值
	      
	      
	      let [x] =[]
	      
	      这叫做结构不成功  是个 undfiend
	      
	      解构默认值
	      
	      例
	      
	        let [y=3]=[]
	        
	        console.log(y)//3
	        
	        
	        默认赋值
	        
	        
	     对象的解构赋值
	     
	     	let {a,b}={b:111,a:444}
	     	
	     	正常解构
	     	
	     	let {a:b}={a:1}
	     	
	     	
	     	console.log(b) //  1
	     	
	     	
	      基本类型额解构赋值
	      
	      let [a,b,c]=123
	      
	      console.log(a,b,c)//1,2,3
	      
	      
	      
	      let {length:len}="22334"
	      
	      console.log(len)//5
	      
	      
	      
	      
	      null  和 undefiend 不能进行解构赋值
	      
	      
	     数据解构
	     
	     
	     
	     set 是集合
	     
	     key和value  是唯一的  没有重复的值
	     
	     
	     const s= new Set([1,2,3])
	     
	     console.log(s)//{1,2,3}
	     
	     
	     set 类的属性是size
	     
	     console.log(s.size)//3  表示有三个属性 
	     
	     
	     set 类的 方法
	     
	        使用这个方法首先要声明这个类
	        
	        const s= new Set([1,2,3])//不能有重复的数据
	     
	        
	        s 是对象的名
	        
	        s.add(value)  添加一个数据 返回这个数据的本身
	
			s.delete(value) 删除指定的值  并返回一个布尔值 如果是true 那么就是成功了
			
			s.has(value)  判断 这个值是否存在 如果存在返回布尔值true 如果么有 就是false
			
			s.clear() 清空了数据
			
			s.keys()
			
			和  s.values()
			
			他们两个的返回值是建名
			
			
			健名 和键值是相同
			
			s.entries()   返回的是键值对
			
			
			s.forEach(function(value,key,set){
				
				.....
				
			})
			
			
			
	    数据结构 map
	    
	    
	        javascript中对象 只能用字符串当做键;
	        
	        为了解决这一问题  es6 提供了map的数据结构 他类似于对象  也是键值对的集合  但是键的范围不局限于字符串,各种类型的值都可以当做建
	        
	        如何创建一个map
	        
	        
	        const map=new Map();
	        
	        
	        可以接收二维数组
	        
	        
	        const map= new Map([
	        		["a",1],
	        		["b",2]
	        ])
	     
	        console.log(map)  //{"a"=>1,"b"=>2}
	        
	        属性
	        
	     	console.log(map.size)//表示当前这个对象内部的元素的个数  
	     	
	   map的方法
	   
	      map.set("miaov","课堂")//这样就把这个值添加到了 map这个对象当中了   并且不会重复  如果重复 后边的会把前边的覆盖掉
	                key    value
	      
	     
	     map.get("miaov") //获取到这个键对应的value值        如果没有返回的是undefiend
	     
	     
	     map.delete("miaov")//删除某个键  如果删除成功返回的是true
	     
	     map.has("miaov")//判断的这个键是否存在如果存在则是true
      
      
        map.clear()//清空 map当中的所有属性
        
        
        map.keys()//返回所有的键名
        
        
        map.values()//遍历所有键值的
        
        
        map.entries()//遍历的是键值对的
        
        map.forEach(function(key,value,map){
        	......
        })
        
        
        map中认为 NaN 是相等的
        
        
	     map中他们认为 如果内存地址不一样视为两个键
	     
	     
	     例
	     {}=x
	     {}=y
	     
	     他们两个是两个空对象  是不一样的
	     
	     
	     空对象和空对象比较是false  不相等
	     
	 key的顺序是按照添加的顺序排列的
	 
	 
	 Iterator  为各种不同的数据结构提供统一的访问机制 任何数据结构只要部署了 Iterator 接口的就可以完成遍历的操作 而且这种的
	 
	 遍历操作时依次处理该数据结构的所有成员
	 
	 
	 新增的  for --of 的循环
	 
	 
	 const arr=[1,2,3]
	 
	 
	 function Iterator(){
	 	
	 	let index=0;
	 	
	 	return {
	 		next:function(){
	 			return index <arr.length?
	 				{value:arr[index++],done:false}:
	 				{value:undefined,done:true}
	 		}
	 	}
	 }
	     
	     
	const it=Iterator(arr)
	
	
	console.log(it.next())//{value:1,done:false}
	console.log(it.next())//{value:2,done:false}
	console.log(it.next())//{value:3,done:false}
	console.log(it.next())//{value:undefined,done:true}
	
	
	
	es6
	
	凡是具有symbol.iterator 属性的数据就会有 Iterator的就口
	
	
	
	
	
	const arr=[1,2,3]
	
	const set =new Set([a,b,c])
	
	const map=new Map([[a,1]]);
	
	
	const itArr=arr[Symbol.iterator]();
	const itSet=set[Symbol.iterator]();
	const itMap=map[Symbol.iterator]();
	
	
	console.log(itArr)
	console.log(itSet)
	console.log(itMap)
	
	
	
	console.log(itSet.next()){value:a,done:false}
	console.log(itSet.next()){value:b,done:false}
	console.log(itSet.next()){value:c,done:false}
	console.log(itSet.next()){value:undefiend,done:false}
	
	
	iterator  本身就是数据结构所具有的 属性 并且他的结构 和next 的方法 本身就是具备的  切返回的结构也是固定的
	
	
	如果返回done是false 说名值还没有比遍历完成,如果返回的是true  就是已经完成了
	
	
	const obj ={}
	
	console.log(obj[Symbol.iterator])//不存在
	
	
	
	凡是具有  iterator 接口的 都可以结构赋值
	
	
	let [x,y]=set
	
	console.log(x,y)//a b
	
	
	
	let str="miaov";
	
	let arrStr=[...str];
	
	console.log(arrStr)// [ "m" "i" "a" "o" "v"]   扩展运算符   用这种方法  就把这个字符串转化成为了 一个数组  分解了
	
	
	
	const arr2=[{},"1","a",1,"a","c",[]];
	
	
	console.log([...new Set(arr2)])//这就出来的是 去重后的数组
	
	
	
	for....of
	
	
	const ofArr=[1,2,3,4];
	
	for(let i of ofArr){
		
		console.log(i)//是这个数组中的每一项的值
		
	}
	
	
	
	
	const m=new Map();
	
	
	m.set('a',1).set("b",2).set("c",3)
	
	for(let [key,value] of m){
		console.log(key,value)
	}
	
	
	
	class 应用
	
	class Miaov{
		constructor(a,b){
			this.a=a;
			this.b=b;
			return this;
		}
		
		print(){
			console.log(this.a+this.b)
		}
		
		print1(){
			console.log(this.a+1)
		}
	}
	
	const miaov= new Miaov("hello","world").print();
	
	
	
	
	类中的方法与方法之间不用逗号隔开
	
	也不用 function 
	
	直接函数名+(){}   就可以了
	
	
	
	
	其实 这些定义的方法 还是定义在pototype上的只是写法不一样了
	
	
	生成类 必须用new
	
	
	   
	class 类的继承
	
	
	class App{
		
	}
	
	     
	class Appone extends App{
		constructor(x,p,r){
			
			super(x,p,r)//继承父类的属性   ES6中 如果没有调用super  子类是没有 属性的  也可以继承静态的方法
			
			this.h=9;
		}
	}
	     
	     
	     
	     
	      
	      
	      
	      
	      
	      
	     	
	     	
	     	
	     	
	     	
	     	
	     	
	     	
	     	
	     	
	     
	        
	        
	        
	        
	        
	        
	      
	      
	      
	      
	      
	      
	      
	      
	      
	      
	      
	      
	      
	      
	      
	    
	    
	           
	           
	           
	           
	         
	   
	   
	   
</body>
</html>