<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>Document</title>
</head>
<body>
	es6
	
	   let  是声明变量的 是一个块级作用域
	   
	   1.产生块级作用域
	   2.没有预解析的过程
	   
	   
	   let 声明的变量 只在他声明的所在代码块内有效
	   
	   例   
	   
	   {
	   	
	   	let a=20;
	   	
	   	let b=1;
	   	
	   }
	   
	   
	   let  适合在 for循环中使用
	   
	   
	   例  
	   
	   for(let i=0;i<10;i++){
	   	  //...
	   }
	   
	   for (let i = 0; i < 3; i++) {
			  let i = 'abc';
			  console.log(i);
			}
			// abc
			// abc
			// abc
	   
	   这里输出了三次abc  说明函数内部变量 i  和  循环变量i  不是同一个作用域
	   
	   
	   let 声明的变量必须在声明后才能使用 否者报错
	   
	   只要块级作用域内 存在let命令 那么他声明的变量 就bind 在这个区域了 不在受到外部的影响
	   
	   例
	   
	   var tmp = 123;

			if (true) {
			  tmp = 'abc'; // ReferenceError  报错
			  let tmp;
			}
	   
	   
	   在代码快内未声明不能使用 叫做暂时性死区
	   
	   在相同的作用域内  不能重复声明同一个变量
	   
	   不能声明参数
	   
	   
		  // 报错
			function () {
			  let a = 10;
			  var a = 1;
			}
			
			// 报错
			function () {
			  let a = 10;
			  let a = 1;
			}
	   
	   
	   function func(arg) {
		  let arg; // 报错
		}
		
		function func(arg) {
		  {
		    let arg; // 不报错
		  }
		}
	   
	   
	   function f1() {
		  let n = 5;
		  if (true) {
		    let n = 10;
		  }
		  console.log(n); // 5   代码块不同 互不干扰
		}
	   
	   
	   外层的代码块是无法使用内层的变量的	   
	   
	   不同的代码区域 可以定义相同的变量
	   
	   块级作用域没有返回值
	   
	   在块级作用域之前 加一个do  那么他就会有 返回值
	   
	   
	   例
	   
	     {    }   两个大括号 就是跨级作用域
	     
	     
	     
	   let x = do {
		  let t = f();
		  t * t + 1;
		};
	   
	     
	   
	   const 是声明常量的
	   
	   
	        常量声明 就不能改变  改变过常量的值会报错
	         
	        这就意味着  一旦声明 常量就得马上赋值   只申明不赋值 就会报错
	        
	        
	        const 和  let  只在区域块有用 
	        
	        
	        常量必须赋值
	        
	        基本数据类型数据不可改变
	        
	        如果是一个对象里面的值可以改变
	        
	        
	        例
	        
	           const a={b:30}
	           
	           
	           a.b=49;
	           
	           console.log(a.b)//49
	           
	           
	    结构赋值
	    
	      let a=1;
	      let b=2;
	      let c=3;
	      
	      类同
	      
	      let [a,b,c]=[1,2,3]
	      
	      
	      数组的结构赋值
	      
	      结构赋值 是一种匹配模式 如果模式相同 就会被赋值
	      
	      
	      let [x] =[]
	      
	      这叫做结构不成功  是个 undfiend
	      
	      解构默认值
	      
	      例
	      
	        let [y=3]=[]
	        
	        console.log(y)//3
	        
	        
	        默认赋值
	        
	        
	     对象的解构赋值
	     
	     	let {a,b}={b:111,a:444}
	     	
	     	正常解构
	     	
	     	let {a:b}={a:1}
	     	
	     	
	     	console.log(b) //  1
	     	
	     	
	      基本类型额解构赋值
	      
	      let [a,b,c]=123
	      
	      console.log(a,b,c)//1,2,3
	      
	      
	      
	      let {length:len}="22334"
	      
	      console.log(len)//5
	      
	      
	      
	      
	      null  和 undefiend 不能进行解构赋值
	      
	      
	     数据解构
	     
	     
	     
	     set 是集合
	     
	     key和value  是唯一的  没有重复的值
	     
	     
	     const a= new Set([1,2,3])
	     
	     console.log(s)//{1,2,3}
	     
	     
	     set 类的属性是size
	     
	     console.log(s.size)//3  表示有三个属性 
	     
	     
	     set 类的 方法
	     
	        使用这个方法首先要声明这个类
	        
	        const s= new Set([1,2,3])//不能有重复的数据
	     
	        
	        s 是对象的名
	        
	        s.add(value)  添加一个数据 返回这个数据的本身
	
			s.delete(value) 删除指定的值  并返回一个布尔值 如果是true 那么就是成功了
			
			s.has(value)  判断 这个值是否存在 如果存在返回布尔值true 如果么有 就是false
			
			s.clear() 清空了数据
			
			s.keys()
			
			和  s.values()
			
			他们两个的返回值是建名
			
			
			健名 和键值是相同
			
			s.entries()   返回的是键值对
			
			
			s.forEach(function(value,key,set){
				
				.....
				
			})
			
			
			
			
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	      
	      
	      
	      
	      
	      
	     	
	     	
	     	
	     	
	     	
	     	
	     	
	     	
	     	
	     	
	     
	        
	        
	        
	        
	        
	        
	      
	      
	      
	      
	      
	      
	      
	      
	      
	      
	      
	      
	      
	      
	      
	    
	    
	           
	           
	           
	           
	         
	   
	   
	   
</body>
</html>